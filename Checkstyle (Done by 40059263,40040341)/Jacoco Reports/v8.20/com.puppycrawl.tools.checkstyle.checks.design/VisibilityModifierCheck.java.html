<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VisibilityModifierCheck.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle.checks.design</a> &gt; <span class="el_source">VisibilityModifierCheck.java</span></div><h1>VisibilityModifierCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2019 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle.checks.design;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FullIdent;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.AnnotationUtil;
import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;

/**
 * Checks visibility of class members. Only static final, immutable or annotated
 * by specified annotation members may be public,
 * other class members must be private unless allowProtected/Package is set.
 * &lt;p&gt;
 * Public members are not flagged if the name matches the public
 * member regular expression (contains &quot;^serialVersionUID$&quot; by
 * default).
 * &lt;/p&gt;
 * Rationale: Enforce encapsulation.
 * &lt;p&gt;
 * Check also has options making it less strict:
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;b&gt;ignoreAnnotationCanonicalNames&lt;/b&gt; - the list of annotations canonical names
 * which ignore variables in consideration, if user will provide short annotation name
 * that type will match to any named the same type without consideration of package,
 * list by default:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;org.junit.Rule&lt;/li&gt;
 * &lt;li&gt;org.junit.ClassRule&lt;/li&gt;
 * &lt;li&gt;com.google.common.annotations.VisibleForTesting&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * For example such public field will be skipped by default value of list above:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code @org.junit.Rule
 * public TemporaryFolder publicJUnitRule = new TemporaryFolder();
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * &lt;b&gt;allowPublicFinalFields&lt;/b&gt; - which allows public final fields. Default value is &lt;b&gt;false&lt;/b&gt;.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;b&gt;allowPublicImmutableFields&lt;/b&gt; - which allows immutable fields to be
 * declared as public if defined in final class. Default value is &lt;b&gt;false&lt;/b&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Field is known to be immutable if:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;It's declared as final&lt;/li&gt;
 * &lt;li&gt;Has either a primitive type or instance of class user defined to be immutable
 * (such as String, ImmutableCollection from Guava and etc)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Classes known to be immutable are listed in &lt;b&gt;immutableClassCanonicalNames&lt;/b&gt; by their
 * &lt;b&gt;canonical&lt;/b&gt; names. List by default:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;java.lang.String&lt;/li&gt;
 * &lt;li&gt;java.lang.Integer&lt;/li&gt;
 * &lt;li&gt;java.lang.Byte&lt;/li&gt;
 * &lt;li&gt;java.lang.Character&lt;/li&gt;
 * &lt;li&gt;java.lang.Short&lt;/li&gt;
 * &lt;li&gt;java.lang.Boolean&lt;/li&gt;
 * &lt;li&gt;java.lang.Long&lt;/li&gt;
 * &lt;li&gt;java.lang.Double&lt;/li&gt;
 * &lt;li&gt;java.lang.Float&lt;/li&gt;
 * &lt;li&gt;java.lang.StackTraceElement&lt;/li&gt;
 * &lt;li&gt;java.lang.BigInteger&lt;/li&gt;
 * &lt;li&gt;java.lang.BigDecimal&lt;/li&gt;
 * &lt;li&gt;java.io.File&lt;/li&gt;
 * &lt;li&gt;java.util.Locale&lt;/li&gt;
 * &lt;li&gt;java.util.UUID&lt;/li&gt;
 * &lt;li&gt;java.net.URL&lt;/li&gt;
 * &lt;li&gt;java.net.URI&lt;/li&gt;
 * &lt;li&gt;java.net.Inet4Address&lt;/li&gt;
 * &lt;li&gt;java.net.Inet6Address&lt;/li&gt;
 * &lt;li&gt;java.net.InetSocketAddress&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * User can override this list via adding &lt;b&gt;canonical&lt;/b&gt; class names to
 * &lt;b&gt;immutableClassCanonicalNames&lt;/b&gt;, if user will provide short class name all
 * that type will match to any named the same type without consideration of package.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;b&gt;Rationale&lt;/b&gt;: Forcing all fields of class to have private modifier by default is good
 * in most cases, but in some cases it drawbacks in too much boilerplate get/set code.
 * One of such cases are immutable classes.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;b&gt;Restriction&lt;/b&gt;: Check doesn't check if class is immutable, there's no checking
 * if accessory methods are missing and all fields are immutable, we only check
 * &lt;b&gt;if current field is immutable by matching a name to user defined list of immutable classes
 * and defined in final class&lt;/b&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Star imports are out of scope of this Check. So if one of type imported via &lt;b&gt;star import&lt;/b&gt;
 * collides with user specified one by its short name - there won't be Check's violation.
 * &lt;/p&gt;
 * Examples:
 * &lt;p&gt;
 * The check will rise 3 violations if it is run with default configuration against the following
 * code example:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code
 * public class ImmutableClass
 * {
 *     public int intValue; // violation
 *     public java.lang.String notes; // violation
 *     public BigDecimal value; // violation
 *
 *     public ImmutableClass(int intValue, BigDecimal value, String notes)
 *     {
 *         this.intValue = intValue;
 *         this.value = value;
 *         this.notes = notes;
 *     }
 * }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * To configure the Check passing fields of type com.google.common.collect.ImmutableSet and
 * java.util.List:
 * &lt;/p&gt;
 * &lt;p&gt;
 * &amp;lt;module name=&amp;quot;VisibilityModifier&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;allowPublicImmutableFields&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
 *   &amp;lt;property name=&amp;quot;immutableClassCanonicalNames&amp;quot; value=&amp;quot;java.util.List,
 *   com.google.common.collect.ImmutableSet&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code
 * public final class ImmutableClass
 * {
 *     public final ImmutableSet&amp;lt;String&amp;gt; includes; // No warning
 *     public final ImmutableSet&amp;lt;String&amp;gt; excludes; // No warning
 *     public final BigDecimal value; // Warning here, type BigDecimal isn't specified as immutable
 *
 *     public ImmutableClass(Collection&amp;lt;String&amp;gt; includes, Collection&amp;lt;String&amp;gt; excludes,
 *                  BigDecimal value)
 *     {
 *         this.includes = ImmutableSet.copyOf(includes);
 *         this.excludes = ImmutableSet.copyOf(excludes);
 *         this.value = value;
 *         this.notes = notes;
 *     }
 * }
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * To configure the Check passing fields annotated with
 * &lt;/p&gt;
 * &lt;pre&gt;@com.annotation.CustomAnnotation&lt;/pre&gt;:

 * &lt;p&gt;
 * &amp;lt;module name=&amp;quot;VisibilityModifier&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;ignoreAnnotationCanonicalNames&amp;quot; value=&amp;quot;
 *   com.annotation.CustomAnnotation&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code @com.annotation.CustomAnnotation
 * String customAnnotated; // No warning
 * }
 * {@code @CustomAnnotation
 * String shortCustomAnnotated; // No warning
 * }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * To configure the Check passing fields annotated with short annotation name
 * &lt;/p&gt;
 * &lt;pre&gt;@CustomAnnotation&lt;/pre&gt;:
 *
 * &lt;p&gt;
 * &amp;lt;module name=&amp;quot;VisibilityModifier&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;ignoreAnnotationCanonicalNames&amp;quot;
 *   value=&amp;quot;CustomAnnotation&amp;quot;/&amp;gt;
 * &amp;lt;/module&amp;gt;
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * {@code @CustomAnnotation
 * String customAnnotated; // No warning
 * }
 * {@code @com.annotation.CustomAnnotation
 * String customAnnotated1; // No warning
 * }
 * {@code @mypackage.annotation.CustomAnnotation
 * String customAnnotatedAnotherPackage; // another package but short name matches
 *                                       // so no violation
 * }
 * &lt;/pre&gt;
 *
 *
 */
@FileStatefulCheck
<span class="fc" id="L239">public class VisibilityModifierCheck</span>
    extends AbstractCheck {

    /**
     * A key is pointing to the warning message text in &quot;messages.properties&quot;
     * file.
     */
    public static final String MSG_KEY = &quot;variable.notPrivate&quot;;

    /** Default immutable types canonical names. */
<span class="fc" id="L249">    private static final List&lt;String&gt; DEFAULT_IMMUTABLE_TYPES = Collections.unmodifiableList(</span>
<span class="fc" id="L250">        Arrays.stream(new String[] {</span>
            &quot;java.lang.String&quot;,
            &quot;java.lang.Integer&quot;,
            &quot;java.lang.Byte&quot;,
            &quot;java.lang.Character&quot;,
            &quot;java.lang.Short&quot;,
            &quot;java.lang.Boolean&quot;,
            &quot;java.lang.Long&quot;,
            &quot;java.lang.Double&quot;,
            &quot;java.lang.Float&quot;,
            &quot;java.lang.StackTraceElement&quot;,
            &quot;java.math.BigInteger&quot;,
            &quot;java.math.BigDecimal&quot;,
            &quot;java.io.File&quot;,
            &quot;java.util.Locale&quot;,
            &quot;java.util.UUID&quot;,
            &quot;java.net.URL&quot;,
            &quot;java.net.URI&quot;,
            &quot;java.net.Inet4Address&quot;,
            &quot;java.net.Inet6Address&quot;,
            &quot;java.net.InetSocketAddress&quot;,
<span class="fc" id="L271">        }).collect(Collectors.toList()));</span>

    /** Default ignore annotations canonical names. */
<span class="fc" id="L274">    private static final List&lt;String&gt; DEFAULT_IGNORE_ANNOTATIONS = Collections.unmodifiableList(</span>
<span class="fc" id="L275">        Arrays.stream(new String[] {</span>
            &quot;org.junit.Rule&quot;,
            &quot;org.junit.ClassRule&quot;,
            &quot;com.google.common.annotations.VisibleForTesting&quot;,
<span class="fc" id="L279">        }).collect(Collectors.toList()));</span>

    /** Name for 'public' access modifier. */
    private static final String PUBLIC_ACCESS_MODIFIER = &quot;public&quot;;

    /** Name for 'private' access modifier. */
    private static final String PRIVATE_ACCESS_MODIFIER = &quot;private&quot;;

    /** Name for 'protected' access modifier. */
    private static final String PROTECTED_ACCESS_MODIFIER = &quot;protected&quot;;

    /** Name for implicit 'package' access modifier. */
    private static final String PACKAGE_ACCESS_MODIFIER = &quot;package&quot;;

    /** Name for 'static' keyword. */
    private static final String STATIC_KEYWORD = &quot;static&quot;;

    /** Name for 'final' keyword. */
    private static final String FINAL_KEYWORD = &quot;final&quot;;

    /** Contains explicit access modifiers. */
<span class="fc" id="L300">    private static final String[] EXPLICIT_MODS = {</span>
        PUBLIC_ACCESS_MODIFIER,
        PRIVATE_ACCESS_MODIFIER,
        PROTECTED_ACCESS_MODIFIER,
    };

    /** Regexp for public members that should be ignored. Note:
     * Earlier versions of checkstyle used ^f[A-Z][a-zA-Z0-9]*$ as the
     * default to allow CMP for EJB 1.1 with the default settings.
     * With EJB 2.0 it is not longer necessary to have public access
     * for persistent fields.
     */
<span class="fc" id="L312">    private Pattern publicMemberPattern = Pattern.compile(&quot;^serialVersionUID$&quot;);</span>

    /** List of ignore annotations short names. */
<span class="fc" id="L315">    private final List&lt;String&gt; ignoreAnnotationShortNames =</span>
<span class="fc" id="L316">            getClassShortNames(DEFAULT_IGNORE_ANNOTATIONS);</span>

    /** List of immutable classes short names. */
<span class="fc" id="L319">    private final List&lt;String&gt; immutableClassShortNames =</span>
<span class="fc" id="L320">        getClassShortNames(DEFAULT_IMMUTABLE_TYPES);</span>

    /** List of ignore annotations canonical names. */
<span class="fc" id="L323">    private List&lt;String&gt; ignoreAnnotationCanonicalNames =</span>
        new ArrayList&lt;&gt;(DEFAULT_IGNORE_ANNOTATIONS);

    /** Whether protected members are allowed. */
    private boolean protectedAllowed;

    /** Whether package visible members are allowed. */
    private boolean packageAllowed;

    /** Allows immutable fields of final classes to be declared as public. */
    private boolean allowPublicImmutableFields;

    /** Allows final fields to be declared as public. */
    private boolean allowPublicFinalFields;

    /** List of immutable classes canonical names. */
<span class="fc" id="L339">    private List&lt;String&gt; immutableClassCanonicalNames = new ArrayList&lt;&gt;(DEFAULT_IMMUTABLE_TYPES);</span>

    /**
     * Set the list of ignore annotations.
     * @param annotationNames array of ignore annotations canonical names.
     */
    public void setIgnoreAnnotationCanonicalNames(String... annotationNames) {
<span class="fc" id="L346">        ignoreAnnotationCanonicalNames = Arrays.asList(annotationNames);</span>
<span class="fc" id="L347">    }</span>

    /**
     * Set whether protected members are allowed.
     * @param protectedAllowed whether protected members are allowed
     */
    public void setProtectedAllowed(boolean protectedAllowed) {
<span class="fc" id="L354">        this.protectedAllowed = protectedAllowed;</span>
<span class="fc" id="L355">    }</span>

    /**
     * Set whether package visible members are allowed.
     * @param packageAllowed whether package visible members are allowed
     */
    public void setPackageAllowed(boolean packageAllowed) {
<span class="fc" id="L362">        this.packageAllowed = packageAllowed;</span>
<span class="fc" id="L363">    }</span>

    /**
     * Set the pattern for public members to ignore.
     * @param pattern
     *        pattern for public members to ignore.
     */
    public void setPublicMemberPattern(Pattern pattern) {
<span class="fc" id="L371">        publicMemberPattern = pattern;</span>
<span class="fc" id="L372">    }</span>

    /**
     * Sets whether public immutable fields are allowed.
     * @param allow user's value.
     */
    public void setAllowPublicImmutableFields(boolean allow) {
<span class="fc" id="L379">        allowPublicImmutableFields = allow;</span>
<span class="fc" id="L380">    }</span>

    /**
     * Sets whether public final fields are allowed.
     * @param allow user's value.
     */
    public void setAllowPublicFinalFields(boolean allow) {
<span class="fc" id="L387">        allowPublicFinalFields = allow;</span>
<span class="fc" id="L388">    }</span>

    /**
     * Set the list of immutable classes types names.
     * @param classNames array of immutable types canonical names.
     */
    public void setImmutableClassCanonicalNames(String... classNames) {
<span class="fc" id="L395">        immutableClassCanonicalNames = Arrays.asList(classNames);</span>
<span class="fc" id="L396">    }</span>

    @Override
    public int[] getDefaultTokens() {
<span class="fc" id="L400">        return getRequiredTokens();</span>
    }

    @Override
    public int[] getAcceptableTokens() {
<span class="fc" id="L405">        return getRequiredTokens();</span>
    }

    @Override
    public int[] getRequiredTokens() {
<span class="fc" id="L410">        return new int[] {</span>
            TokenTypes.VARIABLE_DEF,
            TokenTypes.IMPORT,
        };
    }

    @Override
    public void beginTree(DetailAST rootAst) {
<span class="fc" id="L418">        immutableClassShortNames.clear();</span>
<span class="fc" id="L419">        final List&lt;String&gt; classShortNames =</span>
<span class="fc" id="L420">                getClassShortNames(immutableClassCanonicalNames);</span>
<span class="fc" id="L421">        immutableClassShortNames.addAll(classShortNames);</span>

<span class="fc" id="L423">        ignoreAnnotationShortNames.clear();</span>
<span class="fc" id="L424">        final List&lt;String&gt; annotationShortNames =</span>
<span class="fc" id="L425">                getClassShortNames(ignoreAnnotationCanonicalNames);</span>
<span class="fc" id="L426">        ignoreAnnotationShortNames.addAll(annotationShortNames);</span>
<span class="fc" id="L427">    }</span>

    @Override
    public void visitToken(DetailAST ast) {
<span class="fc bfc" id="L431" title="All 3 branches covered.">        switch (ast.getType()) {</span>
            case TokenTypes.VARIABLE_DEF:
<span class="fc bfc" id="L433" title="All 2 branches covered.">                if (!isAnonymousClassVariable(ast)) {</span>
<span class="fc" id="L434">                    visitVariableDef(ast);</span>
                }
                break;
            case TokenTypes.IMPORT:
<span class="fc" id="L438">                visitImport(ast);</span>
<span class="fc" id="L439">                break;</span>
            default:
<span class="fc" id="L441">                final String exceptionMsg = &quot;Unexpected token type: &quot; + ast.getText();</span>
<span class="fc" id="L442">                throw new IllegalArgumentException(exceptionMsg);</span>
        }
<span class="fc" id="L444">    }</span>

    /**
     * Checks if current variable definition is definition of an anonymous class.
     * @param variableDef {@link TokenTypes#VARIABLE_DEF VARIABLE_DEF}
     * @return true if current variable definition is definition of an anonymous class.
     */
    private static boolean isAnonymousClassVariable(DetailAST variableDef) {
<span class="fc bfc" id="L452" title="All 2 branches covered.">        return variableDef.getParent().getType() != TokenTypes.OBJBLOCK;</span>
    }

    /**
     * Checks access modifier of given variable.
     * If it is not proper according to Check - puts violation on it.
     * @param variableDef variable to check.
     */
    private void visitVariableDef(DetailAST variableDef) {
<span class="fc" id="L461">        final boolean inInterfaceOrAnnotationBlock =</span>
<span class="fc" id="L462">                ScopeUtil.isInInterfaceOrAnnotationBlock(variableDef);</span>

<span class="fc bfc" id="L464" title="All 4 branches covered.">        if (!inInterfaceOrAnnotationBlock &amp;&amp; !hasIgnoreAnnotation(variableDef)) {</span>
<span class="fc" id="L465">            final DetailAST varNameAST = variableDef.findFirstToken(TokenTypes.TYPE)</span>
<span class="fc" id="L466">                .getNextSibling();</span>
<span class="fc" id="L467">            final String varName = varNameAST.getText();</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">            if (!hasProperAccessModifier(variableDef, varName)) {</span>
<span class="fc" id="L469">                log(varNameAST, MSG_KEY, varName);</span>
            }
        }
<span class="fc" id="L472">    }</span>

    /**
     * Checks if variable def has ignore annotation.
     * @param variableDef {@link TokenTypes#VARIABLE_DEF VARIABLE_DEF}
     * @return true if variable def has ignore annotation.
     */
    private boolean hasIgnoreAnnotation(DetailAST variableDef) {
<span class="fc" id="L480">        final DetailAST firstIgnoreAnnotation =</span>
<span class="fc" id="L481">                 findMatchingAnnotation(variableDef);</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        return firstIgnoreAnnotation != null;</span>
    }

    /**
     * Checks imported type. If type's canonical name was not specified in
     * &lt;b&gt;immutableClassCanonicalNames&lt;/b&gt;, but it's short name collides with one from
     * &lt;b&gt;immutableClassShortNames&lt;/b&gt; - removes it from the last one.
     * @param importAst {@link TokenTypes#IMPORT Import}
     */
    private void visitImport(DetailAST importAst) {
<span class="fc bfc" id="L492" title="All 2 branches covered.">        if (!isStarImport(importAst)) {</span>
<span class="fc" id="L493">            final DetailAST type = importAst.getFirstChild();</span>
<span class="fc" id="L494">            final String canonicalName = getCanonicalName(type);</span>
<span class="fc" id="L495">            final String shortName = getClassShortName(canonicalName);</span>

            // If imported canonical class name is not specified as allowed immutable class,
            // but its short name collides with one of specified class - removes the short name
            // from list to avoid names collision
<span class="fc bfc" id="L500" title="All 2 branches covered.">            if (!immutableClassCanonicalNames.contains(canonicalName)) {</span>
<span class="fc" id="L501">                immutableClassShortNames.remove(shortName);</span>
            }
<span class="fc bfc" id="L503" title="All 2 branches covered.">            if (!ignoreAnnotationCanonicalNames.contains(canonicalName)) {</span>
<span class="fc" id="L504">                ignoreAnnotationShortNames.remove(shortName);</span>
            }
        }
<span class="fc" id="L507">    }</span>

    /**
     * Checks if current import is star import. E.g.:
     * &lt;p&gt;
     * {@code
     * import java.util.*;
     * }
     * &lt;/p&gt;
     * @param importAst {@link TokenTypes#IMPORT Import}
     * @return true if it is star import
     */
    private static boolean isStarImport(DetailAST importAst) {
<span class="fc" id="L520">        boolean result = false;</span>
<span class="fc" id="L521">        DetailAST toVisit = importAst;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        while (toVisit != null) {</span>
<span class="fc" id="L523">            toVisit = getNextSubTreeNode(toVisit, importAst);</span>
<span class="fc bfc" id="L524" title="All 4 branches covered.">            if (toVisit != null &amp;&amp; toVisit.getType() == TokenTypes.STAR) {</span>
<span class="fc" id="L525">                result = true;</span>
<span class="fc" id="L526">                break;</span>
            }
        }
<span class="fc" id="L529">        return result;</span>
    }

    /**
     * Checks if current variable has proper access modifier according to Check's options.
     * @param variableDef Variable definition node.
     * @param variableName Variable's name.
     * @return true if variable has proper access modifier.
     */
    private boolean hasProperAccessModifier(DetailAST variableDef, String variableName) {
<span class="fc" id="L539">        boolean result = true;</span>

<span class="fc" id="L541">        final String variableScope = getVisibilityScope(variableDef);</span>

<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (!PRIVATE_ACCESS_MODIFIER.equals(variableScope)) {</span>
<span class="fc" id="L544">            result =</span>
<span class="fc bfc" id="L545" title="All 4 branches covered.">                isStaticFinalVariable(variableDef)</span>
<span class="fc bfc" id="L546" title="All 4 branches covered.">                || packageAllowed &amp;&amp; PACKAGE_ACCESS_MODIFIER.equals(variableScope)</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">                || protectedAllowed &amp;&amp; PROTECTED_ACCESS_MODIFIER.equals(variableScope)</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">                || isIgnoredPublicMember(variableName, variableScope)</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                || isAllowedPublicField(variableDef);</span>
        }

<span class="fc" id="L552">        return result;</span>
    }

    /**
     * Checks whether variable has static final modifiers.
     * @param variableDef Variable definition node.
     * @return true of variable has static final modifiers.
     */
    private static boolean isStaticFinalVariable(DetailAST variableDef) {
<span class="fc" id="L561">        final Set&lt;String&gt; modifiers = getModifiers(variableDef);</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">        return modifiers.contains(STATIC_KEYWORD)</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                &amp;&amp; modifiers.contains(FINAL_KEYWORD);</span>
    }

    /**
     * Checks whether variable belongs to public members that should be ignored.
     * @param variableName Variable's name.
     * @param variableScope Variable's scope.
     * @return true if variable belongs to public members that should be ignored.
     */
    private boolean isIgnoredPublicMember(String variableName, String variableScope) {
<span class="fc bfc" id="L573" title="All 2 branches covered.">        return PUBLIC_ACCESS_MODIFIER.equals(variableScope)</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">            &amp;&amp; publicMemberPattern.matcher(variableName).find();</span>
    }

    /**
     * Checks whether the variable satisfies the public field check.
     * @param variableDef Variable definition node.
     * @return true if allowed.
     */
    private boolean isAllowedPublicField(DetailAST variableDef) {
<span class="fc bfc" id="L583" title="All 6 branches covered.">        return allowPublicFinalFields &amp;&amp; isFinalField(variableDef)</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">            || allowPublicImmutableFields &amp;&amp; isImmutableFieldDefinedInFinalClass(variableDef);</span>
    }

    /**
     * Checks whether immutable field is defined in final class.
     * @param variableDef Variable definition node.
     * @return true if immutable field is defined in final class.
     */
    private boolean isImmutableFieldDefinedInFinalClass(DetailAST variableDef) {
<span class="fc" id="L593">        final DetailAST classDef = variableDef.getParent().getParent();</span>
<span class="fc" id="L594">        final Set&lt;String&gt; classModifiers = getModifiers(classDef);</span>
<span class="fc bfc" id="L595" title="All 4 branches covered.">        return (classModifiers.contains(FINAL_KEYWORD) || classDef.getType() == TokenTypes.ENUM_DEF)</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                &amp;&amp; isImmutableField(variableDef);</span>
    }

    /**
     * Returns the set of modifier Strings for a VARIABLE_DEF or CLASS_DEF AST.
     * @param defAST AST for a variable or class definition.
     * @return the set of modifier Strings for defAST.
     */
    private static Set&lt;String&gt; getModifiers(DetailAST defAST) {
<span class="fc" id="L605">        final DetailAST modifiersAST = defAST.findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc" id="L606">        final Set&lt;String&gt; modifiersSet = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">        if (modifiersAST != null) {</span>
<span class="fc" id="L608">            DetailAST modifier = modifiersAST.getFirstChild();</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">            while (modifier != null) {</span>
<span class="fc" id="L610">                modifiersSet.add(modifier.getText());</span>
<span class="fc" id="L611">                modifier = modifier.getNextSibling();</span>
            }
        }
<span class="fc" id="L614">        return modifiersSet;</span>
    }

    /**
     * Returns the visibility scope for the variable.
     * @param variableDef Variable definition node.
     * @return one of &quot;public&quot;, &quot;private&quot;, &quot;protected&quot;, &quot;package&quot;
     */
    private static String getVisibilityScope(DetailAST variableDef) {
<span class="fc" id="L623">        final Set&lt;String&gt; modifiers = getModifiers(variableDef);</span>
<span class="fc" id="L624">        String accessModifier = PACKAGE_ACCESS_MODIFIER;</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">        for (final String modifier : EXPLICIT_MODS) {</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">            if (modifiers.contains(modifier)) {</span>
<span class="fc" id="L627">                accessModifier = modifier;</span>
<span class="fc" id="L628">                break;</span>
            }
        }
<span class="fc" id="L631">        return accessModifier;</span>
    }

    /**
     * Checks if current field is immutable:
     * has final modifier and either a primitive type or instance of class
     * known to be immutable (such as String, ImmutableCollection from Guava and etc).
     * Classes known to be immutable are listed in
     * {@link VisibilityModifierCheck#immutableClassCanonicalNames}
     * @param variableDef Field in consideration.
     * @return true if field is immutable.
     */
    private boolean isImmutableField(DetailAST variableDef) {
<span class="fc" id="L644">        boolean result = false;</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">        if (isFinalField(variableDef)) {</span>
<span class="fc" id="L646">            final DetailAST type = variableDef.findFirstToken(TokenTypes.TYPE);</span>
<span class="fc" id="L647">            final boolean isCanonicalName = isCanonicalName(type);</span>
<span class="fc" id="L648">            final String typeName = getTypeName(type, isCanonicalName);</span>
<span class="fc bfc" id="L649" title="All 4 branches covered.">            if (immutableClassShortNames.contains(typeName)</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">                    || isCanonicalName &amp;&amp; immutableClassCanonicalNames.contains(typeName)) {</span>
<span class="fc" id="L651">                final DetailAST typeArgs = getGenericTypeArgs(type, isCanonicalName);</span>

<span class="fc bfc" id="L653" title="All 2 branches covered.">                if (typeArgs == null) {</span>
<span class="fc" id="L654">                    result = true;</span>
                }
                else {
<span class="fc" id="L657">                    final List&lt;String&gt; argsClassNames = getTypeArgsClassNames(typeArgs);</span>
<span class="fc" id="L658">                    result = areImmutableTypeArguments(argsClassNames);</span>
                }
<span class="fc" id="L660">            }</span>
            else {
<span class="fc bfc" id="L662" title="All 4 branches covered.">                result = !isCanonicalName &amp;&amp; isPrimitive(type);</span>
            }
        }
<span class="fc" id="L665">        return result;</span>
    }

    /**
     * Checks whether type definition is in canonical form.
     * @param type type definition token.
     * @return true if type definition is in canonical form.
     */
    private static boolean isCanonicalName(DetailAST type) {
<span class="fc bfc" id="L674" title="All 2 branches covered.">        return type.getFirstChild().getType() == TokenTypes.DOT;</span>
    }

    /**
     * Returns generic type arguments token.
     * @param type type token.
     * @param isCanonicalName whether type name is in canonical form.
     * @return generic type arguments token.
     */
    private static DetailAST getGenericTypeArgs(DetailAST type, boolean isCanonicalName) {
        final DetailAST typeArgs;
<span class="fc bfc" id="L685" title="All 2 branches covered.">        if (isCanonicalName) {</span>
            // if type class name is in canonical form, abstract tree has specific structure
<span class="fc" id="L687">            typeArgs = type.getFirstChild().findFirstToken(TokenTypes.TYPE_ARGUMENTS);</span>
        }
        else {
<span class="fc" id="L690">            typeArgs = type.findFirstToken(TokenTypes.TYPE_ARGUMENTS);</span>
        }
<span class="fc" id="L692">        return typeArgs;</span>
    }

    /**
     * Returns a list of type parameters class names.
     * @param typeArgs type arguments token.
     * @return a list of type parameters class names.
     */
    private static List&lt;String&gt; getTypeArgsClassNames(DetailAST typeArgs) {
<span class="fc" id="L701">        final List&lt;String&gt; typeClassNames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L702">        DetailAST type = typeArgs.findFirstToken(TokenTypes.TYPE_ARGUMENT);</span>
<span class="fc" id="L703">        boolean isCanonicalName = isCanonicalName(type);</span>
<span class="fc" id="L704">        String typeName = getTypeName(type, isCanonicalName);</span>
<span class="fc" id="L705">        typeClassNames.add(typeName);</span>
<span class="fc" id="L706">        DetailAST sibling = type.getNextSibling();</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        while (sibling.getType() == TokenTypes.COMMA) {</span>
<span class="fc" id="L708">            type = sibling.getNextSibling();</span>
<span class="fc" id="L709">            isCanonicalName = isCanonicalName(type);</span>
<span class="fc" id="L710">            typeName = getTypeName(type, isCanonicalName);</span>
<span class="fc" id="L711">            typeClassNames.add(typeName);</span>
<span class="fc" id="L712">            sibling = type.getNextSibling();</span>
        }
<span class="fc" id="L714">        return typeClassNames;</span>
    }

    /**
     * Checks whether all of generic type arguments are immutable.
     * If at least one argument is mutable, we assume that the whole list of type arguments
     * is mutable.
     * @param typeArgsClassNames type arguments class names.
     * @return true if all of generic type arguments are immutable.
     */
    private boolean areImmutableTypeArguments(List&lt;String&gt; typeArgsClassNames) {
<span class="fc" id="L725">        return typeArgsClassNames.stream().noneMatch(</span>
            typeName -&gt; {
<span class="fc bfc" id="L727" title="All 2 branches covered.">                return !immutableClassShortNames.contains(typeName)</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                    &amp;&amp; !immutableClassCanonicalNames.contains(typeName);</span>
            });
    }

    /**
     * Checks whether current field is final.
     * @param variableDef field in consideration.
     * @return true if current field is final.
     */
    private static boolean isFinalField(DetailAST variableDef) {
<span class="fc" id="L738">        final DetailAST modifiers = variableDef.findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">        return modifiers.findFirstToken(TokenTypes.FINAL) != null;</span>
    }

    /**
     * Gets the name of type from given ast {@link TokenTypes#TYPE TYPE} node.
     * If type is specified via its canonical name - canonical name will be returned,
     * else - short type's name.
     * @param type {@link TokenTypes#TYPE TYPE} node.
     * @param isCanonicalName is given name canonical.
     * @return String representation of given type's name.
     */
    private static String getTypeName(DetailAST type, boolean isCanonicalName) {
        final String typeName;
<span class="fc bfc" id="L752" title="All 2 branches covered.">        if (isCanonicalName) {</span>
<span class="fc" id="L753">            typeName = getCanonicalName(type);</span>
        }
        else {
<span class="fc" id="L756">            typeName = type.getFirstChild().getText();</span>
        }
<span class="fc" id="L758">        return typeName;</span>
    }

    /**
     * Checks if current type is primitive type (int, short, float, boolean, double, etc.).
     * As primitive types have special tokens for each one, such as:
     * LITERAL_INT, LITERAL_BOOLEAN, etc.
     * So, if type's identifier differs from {@link TokenTypes#IDENT IDENT} token - it's a
     * primitive type.
     * @param type Ast {@link TokenTypes#TYPE TYPE} node.
     * @return true if current type is primitive type.
     */
    private static boolean isPrimitive(DetailAST type) {
<span class="fc bfc" id="L771" title="All 2 branches covered.">        return type.getFirstChild().getType() != TokenTypes.IDENT;</span>
    }

    /**
     * Gets canonical type's name from given {@link TokenTypes#TYPE TYPE} node.
     * @param type DetailAST {@link TokenTypes#TYPE TYPE} node.
     * @return canonical type's name
     */
    private static String getCanonicalName(DetailAST type) {
<span class="fc" id="L780">        final StringBuilder canonicalNameBuilder = new StringBuilder(256);</span>
<span class="fc" id="L781">        DetailAST toVisit = type.getFirstChild();</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">        while (toVisit != null) {</span>
<span class="fc" id="L783">            toVisit = getNextSubTreeNode(toVisit, type);</span>
<span class="fc bfc" id="L784" title="All 4 branches covered.">            if (toVisit != null &amp;&amp; toVisit.getType() == TokenTypes.IDENT) {</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">                if (canonicalNameBuilder.length() &gt; 0) {</span>
<span class="fc" id="L786">                    canonicalNameBuilder.append('.');</span>
                }
<span class="fc" id="L788">                canonicalNameBuilder.append(toVisit.getText());</span>
<span class="fc" id="L789">                final DetailAST nextSubTreeNode = getNextSubTreeNode(toVisit, type);</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">                if (nextSubTreeNode != null</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">                        &amp;&amp; nextSubTreeNode.getType() == TokenTypes.TYPE_ARGUMENTS) {</span>
<span class="fc" id="L792">                    break;</span>
                }
<span class="fc" id="L794">            }</span>
        }
<span class="fc" id="L796">        return canonicalNameBuilder.toString();</span>
    }

    /**
     * Gets the next node of a syntactical tree (child of a current node or
     * sibling of a current node, or sibling of a parent of a current node).
     * @param currentNodeAst Current node in considering
     * @param subTreeRootAst SubTree root
     * @return Current node after bypassing, if current node reached the root of a subtree
     *        method returns null
     */
    private static DetailAST
        getNextSubTreeNode(DetailAST currentNodeAst, DetailAST subTreeRootAst) {
<span class="fc" id="L809">        DetailAST currentNode = currentNodeAst;</span>
<span class="fc" id="L810">        DetailAST toVisitAst = currentNode.getFirstChild();</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        while (toVisitAst == null) {</span>
<span class="fc" id="L812">            toVisitAst = currentNode.getNextSibling();</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">            if (currentNode.getParent().getColumnNo() == subTreeRootAst.getColumnNo()) {</span>
<span class="fc" id="L814">                break;</span>
            }
<span class="fc" id="L816">            currentNode = currentNode.getParent();</span>
        }
<span class="fc" id="L818">        return toVisitAst;</span>
    }

    /**
     * Gets the list with short names classes.
     * These names are taken from array of classes canonical names.
     * @param canonicalClassNames canonical class names.
     * @return the list of short names of classes.
     */
    private static List&lt;String&gt; getClassShortNames(List&lt;String&gt; canonicalClassNames) {
<span class="fc" id="L828">        final List&lt;String&gt; shortNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">        for (String canonicalClassName : canonicalClassNames) {</span>
<span class="fc" id="L830">            final String shortClassName = canonicalClassName</span>
<span class="fc" id="L831">                    .substring(canonicalClassName.lastIndexOf('.') + 1);</span>
<span class="fc" id="L832">            shortNames.add(shortClassName);</span>
<span class="fc" id="L833">        }</span>
<span class="fc" id="L834">        return shortNames;</span>
    }

    /**
     * Gets the short class name from given canonical name.
     * @param canonicalClassName canonical class name.
     * @return short name of class.
     */
    private static String getClassShortName(String canonicalClassName) {
<span class="fc" id="L843">        return canonicalClassName</span>
<span class="fc" id="L844">                .substring(canonicalClassName.lastIndexOf('.') + 1);</span>
    }

    /**
     * Checks whether the AST is annotated with
     * an annotation containing the passed in regular
     * expression and return the AST representing that
     * annotation.
     *
     * &lt;p&gt;
     * This method will not look for imports or package
     * statements to detect the passed in annotation.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * To check if an AST contains a passed in annotation
     * taking into account fully-qualified names
     * (ex: java.lang.Override, Override)
     * this method will need to be called twice. Once for each
     * name given.
     * &lt;/p&gt;
     *
     * @param variableDef {@link TokenTypes#VARIABLE_DEF variable def node}.
     * @return the AST representing the first such annotation or null if
     *         no such annotation was found
     */
    private DetailAST findMatchingAnnotation(DetailAST variableDef) {
<span class="fc" id="L871">        DetailAST matchingAnnotation = null;</span>

<span class="fc" id="L873">        final DetailAST holder = AnnotationUtil.getAnnotationHolder(variableDef);</span>

<span class="fc" id="L875">        for (DetailAST child = holder.getFirstChild();</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">            child != null; child = child.getNextSibling()) {</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">            if (child.getType() == TokenTypes.ANNOTATION) {</span>
<span class="fc" id="L878">                final DetailAST ast = child.getFirstChild();</span>
<span class="fc" id="L879">                final String name =</span>
<span class="fc" id="L880">                    FullIdent.createFullIdent(ast.getNextSibling()).getText();</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">                if (ignoreAnnotationCanonicalNames.contains(name)</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">                         || ignoreAnnotationShortNames.contains(name)) {</span>
<span class="fc" id="L883">                    matchingAnnotation = child;</span>
<span class="fc" id="L884">                    break;</span>
                }
            }
        }

<span class="fc" id="L889">        return matchingAnnotation;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>